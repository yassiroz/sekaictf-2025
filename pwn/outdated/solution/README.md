## Writeup

The vulnerability is the fact that the user-provided `level` value is a signed integer that doesn't perform bounds checking. Since it's used as the index to the `level_rewards` array of unsigned shorts, that gives the attacker a single out-of-bounds (OOB) write of 2 bytes relative to a stack variable. While participants may first think of a partial overwrite on `$pc` or `$s8` (stack pointer), the `main()` function runs `exit()` and never returns, meaning those saved registers will never be accessed.

MIPS has a `$gp` register (global pointer) that it uses as the offset to calculate any addresses subjected to address randomization (PIE or ASLR). The `$gp` register is stored **underneath** the stack (not above, like `$pc` and `$s8`), and is refilled from this stack value **after every function call**. The relative OOB write gives you the ability to perform a partial overwrite on this saved `$gp` register in the stack, and after calling `printf()`, the saved `$gp` value gets populated into the `$gp` register. This means both the `puts()` and `exit()` function calls use the attacker-controlled `$gp` value to calculate the addresses of those functions, giving us control over both. In addition, the argument to `puts()` is a hard-coded string stored in the `.rodata` section of the binary; however, since PIE is enabled, this address is also unknown at compile time, so its address *also* uses `$gp` to be calculated, giving the attacker control over the first argument to `puts()` also.

Since QEMU has a custom patch for ASLR (granted it's really only one byte of ASLR, hence the long PoW), we don't know the address of `system()` and there's nothing super helpful in the executable (which we know the address of since it was leaked). Therefore, the first "GP overwrite" exploitation can be used to transform the `puts("Thanks for playing! Come again!");` function call into `puts_blue(&GOT['puts'])`, and the `exit(0)` function call can be transformed into `main()` for a second shot at exploitation, but this time with a known libc address. The second "GP overwrite" can turn the `puts()` call into `system("/bin/sh")`, giving the attacker a shell.

The value of `$gp` is normally a static offset from the Global Offset Table. By changing the `$gp` value with our overwrite, we're changing the location of the GOT to point to our own controlled "fake GOT". The `game_name` variable is 0x60 bytes large and is a global, meaning it's at a known location for us and large enough to simulate a GOT. Therefore, both GP overwrites should change `$gp` to be at a static offset from `game_name`. The fake GOT then controls the addresses of each function and the argument to the first function call (after the overwrite).

This is all automated in `solve.py`.