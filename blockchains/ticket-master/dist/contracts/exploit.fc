#include "imports/stdlib.fc";
#include "common/utils.fc";
#include "common/opcode.fc";
#include "common/errors.fc";
#include "common/constants.fc";

;;;;;;;;;; Exploit Storage ;;;;;;;;;;

global slice exploit::my_account;

() exploit::load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    ds.end_parse();
}

() exploit::save_data() impure inline_ref {
    begin_cell()
    .end_cell()
    .set_data();
}

;;;;;;;;;; Exploit Contract ;;;;;;;;;;

const int exploit::op::run = "run"c; ;; 5076a4c0

() recv_internal(int my_balance, int ctx::value, cell in_msg_full, slice ctx::body) impure {
    slice s = in_msg_full.begin_parse();
    int flags = s~load_msg_flags();

    if (is_bounced(flags) | ctx::body.slice_empty?()) {
        ;; ignore bounced messages and empty messages
        return ();
    }

    (slice ctx::sender, int ctx::fwd_fee) = s~retrieve_ctx(BASECHAIN);

    (int op, int query_id) = ctx::body~load_op_and_query_id();

    if op == exploit::op::run {
        slice service_counter = ctx::body~load_msg_addr();
        slice coin_minter = ctx::body~load_msg_addr();
        slice ticket_minter = ctx::body~load_msg_addr();

        return ();
    }

}